\section{ACTA-8000启动}
\subsection{CPUA启动}
串口线连接到RSPE的COM-A上。执行reboot命令重启RSPE，当它进入UBoot后输入Ctrl+C，使其停留在UBoot命令行界面。
下载Linux镜像：
\begin{shellcmd}
tftpboot 0 vmlinux.64.iscsi.order
\end{shellcmd}

其中，vmlinux.64.iscsi.order是Linux镜像（Linux内核需要在编译时选择支持crc32c），目前已经被预先放置在文件服务器的usr/local/nginx/html目录下。
如果上述过程不成功，需要确保物理连接畅通，同时SPI6被设置为UBoot默认端口，且SPI6地址和文件服务器在同一网段内：
\begin{shellcmd}
setenv ethact spi6
setenv ipaddr 192.168.10.224
\end{shellcmd}

下载镜像成功后，加载镜像：
\begin{shellcmd}
bootoctlinux 0 coremask=0xffff mem=0
\end{shellcmd}

coremask对应16个CPU的掩码，0xffff表示16个CPU全部加载，mem后为内存大小（MB）,mem=0表示全部内存。
进入linux后，配置IP:
\begin{shellcmd}
ifconfig spi6 192.168.10.224
ifconfig spi7 192.168.0.224
\end{shellcmd}

从文件服务器下载iscsi相关软件包（目前已经被预先放置在文件服务器）并解压：
\begin{shellcmd}
tftp -g -r iscsi.tar.gz 192.168.10.233
tar xzvf iscsi.tar.gz
cd iscsi
chmod +x *
\end{shellcmd}

\section{设置bootcmd}
\begin{verbatim}
setenv bootcmd tftpboot 0 p\;bootoct 0 coremask=0xff
\end{verbatim}
\section{OCTEON模拟器环境下的GDB调试}
需要两个终端。

终端1:
\begin{verbatim}
oct-sim $(TARGET) -quiet -noperf -numcores=2 -uart1=2021 -debug
\end{verbatim}


终端2:
\begin{verbatim}
 mipsisa64-octeon-elf-gdb -x gdbfile_pc 
\end{verbatim}
上述gdbfile\_pc的内容为:

\begin{verbatim}
file pushtest
set spawn-sim off
target octeon tcp::2021
b main
set step-all on
c
\end{verbatim}

然后就可以正常调试了。

\section{OCTEON服务器登录}

\subsection{ACTA-7200登录}
使用telnet登陆7220后执行oct-serial 2命令登陆CPU-B。Ctrl+A+C退出CPU-B。dpbreset 2重启CPU-B。

运行文件服务器上的hello程序：
\begin{shellcmd}
tftpboot 0 hello
bootoct 0 coremask=*** stack=*** heap=***
\end{shellcmd}

\subsection{Hili登录}
DRM组目前有两台Hili，分别登录194和130服务器，在root权限下使用minicom登录。

\begin{verbatim}
minicom configuration A
minicom configuration B
\end{verbatim}

上述命令分别登录CPA-A和CPU-B
\section{OCTEON-SDK的使用}

\subsection{安装SDK}
\begin{shellcmd}
rpm –i /media/cdrom/*.rpm
/media/cdrom/patch_1.7
\end{shellcmd}
如果SVN中已经安装了SDK,可通过如下命令安装到用户目录下
\begin{shellcmd}
svn checkout http://192.168.1.199/svn/OCTEON-SDK/branches/2012-03-27/
\end{shellcmd}

\subsection{设置环境变量}
执行env-setup脚本会设置环境变量:
\begin{shellcmd}
source env-setup OCTEON_CN58XX
\end{shellcmd}
上述命令需要每次开机时重新执行.如需自动执行,Cavium幻灯片上有如下说明:
Add the following 3 lines to your ~/.bash\_profile and log out/in:
\begin{shellcmd}
pushd /usr/local/Cavium_Networks/OCTEON-SDK
source env-setup OCTEON_CN38XX
popd
\end{shellcmd}


\subsection{查看SDK版本}
查看executive/cvmx-version.h文件内容即可。

\section{开机运行}
\subsection{CPUA启动}
串口线连接到RSPE的COM-A上。执行reboot命令重启RSPE，当它进入UBoot后输入Ctrl+C，使其停留在UBoot命令行界面。
下载Linux镜像：
\begin{shellcmd}
tftpboot 0 vmlinux.64.iscsi.order
\end{shellcmd}

其中，vmlinux.64.iscsi.order是Linux镜像（Linux内核需要在编译时选择支持crc32c），目前已经被预先放置在文件服务器的usr/local/nginx/html目录下。
如果上述过程不成功，需要确保物理连接畅通，同时SPI6被设置为UBoot默认端口，且SPI6地址和文件服务器在同一网段内：
\begin{shellcmd}
setenv ethact spi6
setenv ipaddr 192.168.10.224
\end{shellcmd}

下载镜像成功后，加载镜像：
\begin{shellcmd}
bootoctlinux 0 coremask=0xffff mem=0
\end{shellcmd}

coremask对应16个CPU的掩码，0xffff表示16个CPU全部加载，mem后为内存大小（MB）,mem=0表示全部内存。
进入linux后，配置IP:
\begin{shellcmd}
ifconfig spi6 192.168.10.224
ifconfig spi7 192.168.0.224
\end{shellcmd}

从文件服务器下载iscsi相关软件包（目前已经被预先放置在文件服务器）并解压：
\begin{shellcmd}
tftp -g -r iscsi.tar.gz 192.168.10.233
tar xzvf iscsi.tar.gz
cd iscsi
chmod +x *
\end{shellcmd}

\section{SE程序设计与编译}
\subsection{资源配置}
Static configuration of the hardware resources are controlled by the include file "cvmx-config.h". This file is generated from the executive-config.h file and other files in the config directory of the application. 
Example: creating an application that uses simple executive
\begin{shellcmd}
% mkdir application
% cd application
% mkdir config
% cp $OCTEON_ROOT/executive/executive-config.h.template config/executive-config.h
\end{shellcmd}
(then edit config/executive-config.h to tune the flags/settings as appropriate for the application)
\section{IP-SAN连接}
加载iscsi相关模块：
\begin{shellcmd}
modprobe crc32c;
insmod iomtr_kstat.ko;
insmod scsi_transport_iscsi_dxf.ko;
insmod libiscsi_dxf.ko;
insmod iscsi_tcp_dxf.ko;
echo "127.0.0.1       localhost.localdomain   localhost" > /etc/host;
mkdir /var/lock/;
\end{shellcmd}

配置initiator端id，即IQN。主机的IQN必须经过磁盘阵列客户端的“定义”。
\begin{shellcmd}
mkdir /etc/iscsi;
echo "InitiatorName=iqn.2002-10.com.infortrend:raid.sn7905538.309" > /etc/iscsi/initiatorname.iscsi;
\end{shellcmd}

启动iscsi守护进程
\begin{shellcmd}
./iscsid_dxf;
\end{shellcmd}

寻找远程磁盘。在解压出的iscsi目录下，执行
\begin{shellcmd}
./iscsiadm_dxf -m discovery -t sendtargets -p 192.168.0.17;
\end{shellcmd}

该IP下的磁盘记录信息会被获取到本地。如果需要（如磁盘连接异常需重新连接），可用以下命令清空记录：
\begin{shellcmd}
./iscsiadm_dxf -m node -o delete
\end{shellcmd}

获取盘阵信息后，进行iscsi登录，连接磁盘：
\begin{shellcmd}
./iscsiadm_dxf -m node  -p 192.168.0.17 -l;
\end{shellcmd}

查看磁盘挂载情况：
\begin{shellcmd}
fdisk -l;
\end{shellcmd}

获取iscsi会话信息
\begin{shellcmd}
./iscsiadm_dxf -m session -P3
\end{shellcmd}




\section{运行时系统信息识别}

\subsection{processor\_id}
cvmx.h中定义了\verb+cvmx_get_proc_id+函数。所谓processor\_id，应该是用于标示处理器的型号。例如有cvmx.h中有如下代码：
\begin{verbatim}
 return (cvmx_get_proc_id() == OCTEON_CN38XX_PASS1);
\end{verbatim}


\subsection{OCTEON MODEL识别}
使用\verb|OCTEON_IS_MODEL(x)|宏可判断是否为模型x。该宏和x可取的值定义在executive/octeon\_model.h中。

\subsection{是否为模拟器}
\begin{verbatim}
cvmx_sysinfo_get() 返回值的board_type字段代表“板子”类型，其取值由enum cvmx_board_types_enum定义。对于模拟器，取CVMX_BOARD_TYPE_SIM。
\end{verbatim}


