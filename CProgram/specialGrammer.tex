\section{C/C++特殊语法}

\subsection{空结构体(类)大小}
在C语言中，空结构体大小为0，空结构体数组的每个元素都有相同的地址，如果求取数组两个元素的偏移(\verb|&array[1]-&array[0]|),运行时会发生浮点例外。因为会转化为地址差除以元素大小。同理，指针增减操作会转为绝对地址增减乘以元素大小，因此指针位置不会改变。
C++规定任意两个不同对象不可以有相同地址，因此空结构体和空类的大小为1，如果类中只包含一个char成员，类大小也为1(g++验证)。

\subsection{整数运算}
两个整数作\verb+&&,||,!+逻辑运算只有0和1两种结果。做\verb+&,|,^,~+等位运算，相当于每一bit分别运算,注意取反运算的结果与整数本身的位数有关。

\subsection{压栈顺序}
C标准中未规定参数压栈顺序，但VC和gcc都规定从右往左压栈。如果参数中含有表达式，会从右到左计算完表达式的值，再从右到左压栈。对于形如a++的后自增参数，在计算表达式时创建副本，未来将副本压栈，也相当于在计算表达式之前就将表达式本身压栈了。而形如++a的前自增参数，是将a本身压栈，a的值为所有表达式都计算完成之后时刻的值。
例如，\verb|a=12|，1.\verb|printf("%d, %d\n", ++a, ++a)|,2.\verb|printf("%d, %d\n", ++a, a++)|,3.\verb|printf("%d, %d\n", a++, ++a)|,4.\verb|printf("%d, %d\n", --a, a++)|,5.\verb|printf("%d, %d\n", a--, ++a)|的结果分别为：
\verb|14,14;14,12;13,14;12,12;13,12|。

此外，运算符两侧的两个表达式的计算顺序是未定义的，如\verb|func1()*func2(), if (a[i++]<b[i])|等。

\subsection{自赋值初始化}
\verb+int a = 2; int main() {int a = a;}+的结果是未定义的。


\subsection{强制类型转换}
将浮点数赋值给整数，相当于取整。

\subsection{字符数组长度}
字符数组长度(使用sizeof()求取)等于字符串长度加1, 因为末尾的零也占一位。
而指向字符串的char*变量的长度则为指针长度(比如4)。

这是字符串与字符数组的区别之一。

二者都可以用静态字符串变量初始化。


