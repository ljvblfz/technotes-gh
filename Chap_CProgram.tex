\section{常见错误}

条件表达式容易发生如下错误，如:
\begin{verbatim}
    n_cdn_cache_buf = avRate / BASE_MBPS + (avRate % BASE_MBPS)?(1):(0);
\end{verbatim}
注意加法优先级大于？优先级，程序员的本意可能想表达:
\begin{verbatim}
    n_cdn_cache_buf = avRate / BASE_MBPS + ((avRate % BASE_MBPS)?(1):(0));
\end{verbatim}
但实际表达效果为:

\begin{verbatim}
    n_cdn_cache_buf = (avRate / BASE_MBPS + avRate % BASE_MBPS)?(1):(0);
\end{verbatim}


\section{C/C++ man手册页}
对于Ubuntu12.04,默认已经安装了C语言的手册页。对于C++，
需要安装libstdc++6-4.4-doc软件包。安装之后，\verb+man std::string+
将返回C++ string的手册页。
搜索libstdc++-doc版本，可以
\begin{shellcmd}
	apt-cache search libstdc++|grep "doc"
\end{shellcmd}


对于Linux Deepin12.06，没有预装C手册页。需要安装
manpages-dev, libstdc++-\ldots-doc软件包。C++ man页检索很不方便，如没有std::string主题，只有\verb+std_basic_string+。可以用以下方式查找vector手册内容:
\begin{shellcmd}
	apropos std_vector |grep cxx
\end{shellcmd}

其他相关软件包包括：manpages-posix,manpages-posix-dev

\url{ftp://gcc.gnu.org/pub/gcc/libstdc++/doxygen/}可以下载离线版本的libstdc++手册。

另外，cppreference.com和cplusplus.com是较常用的C++参考手册网站。

manpages-cpp网站包可用来提取cplusplus.com网站的信息
\begin{shellcmd}
	sudo add-apt-repository ppa:aitjcize/manpages-cpp
	sudo apt-get update
	sudo apt-get install manpages-cpp
	cppman -c (Cache离线信息)
\end{shellcmd}


\section{C++中extern “C”含义深层探索}
\subsection{引言}
　　C++语言的创建初衷是“a better C”，但是这并不意味着C++中类似C语言的全局变量和函数所采用的编译和连接方式与C语言完全相同。作为一种欲与C兼容的语言，C++保留了一部分过程式语言的特点（被世人称为“不彻底地面向对象”），因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的程序设计语言，为了支持函数的重载，C++对全局函数的处理方式与C有明显的不同。

\subsection{从标准头文件说起}
某企业曾经给出如下的一道面试题：
\begin{verbatim}
 面试题
　　为什么标准头文件都有类似以下的结构？


#ifndef __INCvxWorksh
#define __INCvxWorksh 
#ifdef __cplusplus
extern "C" {
#endif 
/*...*/ 
#ifdef __cplusplus
}
#endif 
#endif /* __INCvxWorksh */


　　分析
　　显然，头文件中的编译宏“#ifndef __INCvxWorksh、#define __INCvxWorksh、#endif” 的作用是防止该头文件被重复引用。

　　那么

#ifdef __cplusplus
extern "C" {
#endif 
#ifdef __cplusplus
}
#endif


　　的作用又是什么呢？我们将在下文一一道来。
\end{verbatim} 
\subsection{深层揭密extern "C"}
　extern "C" 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。让我们来详细解读这两重含义。

　　被extern "C"限定的函数或变量是extern类型的；

　　extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。记住，下列语句：

　　extern int a;

　　仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。

　　通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。

　　与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。

　　被extern "C"修饰的变量和函数是按照C语言方式编译和连接的；

　　未加extern “C”声明时的编译方式

　　首先看看C++中对类似C的函数是怎样编译的。

　　作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：

void foo( int x, int y );


　　该函数被C编译器编译后在符号库中的名字为\_foo，而C++编译器则会产生像\verb|_foo_int_int|之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。

　　\verb|_foo_int_int|这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo(int x, int y)与void foo(int x, float y)编译生成的符号是不相同的，后者为\verb|_foo_int_float|。
　　同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以"."来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。

　　未加extern "C"声明时的连接方式

　　假设在C++中，模块A的头文件如下：
\begin{verbatim}
　

// 模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
int foo( int x, int y );
#endif


　　在模块B中引用该函数：

// 模块B实现文件　moduleB.cpp
#include "moduleA.h"
foo(2,3);
\end{verbatim} 　

　　实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找\verb|_foo_int_int|这样的符号！

　　加extern "C"声明后的编译和连接方式

　　加extern "C"声明后，模块A的头文件变为：
\begin{verbatim}
 // 模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
extern "C" int foo( int x, int y );
#endif
\end{verbatim} 

　　在模块B的实现文件中仍然调用foo( 2,3 )，其结果是：

　　（1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式；

　　（2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名\_foo。

　　如果在模块A中函数声明了foo为extern "C"类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。

　　所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：
　　实现C++与C及其它语言的混合编程。
　　明白了C++中extern "C"的设立动机，我们下面来具体分析extern "C"通常的使用技巧。
　　
\subsection{extern "C"的惯用法}
\subsubsection{在C++中引用C语言中的函数和变量}


在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：
\begin{verbatim}
 extern "C"
{
#include "cExample.h"
}

\end{verbatim} 
　　而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。
　　笔者编写的C++引用C函数例子工程中包含的三个文件的源代码如下：
\begin{verbatim}
 /* c语言头文件：cExample.h */
#ifndef C_EXAMPLE_H
#define C_EXAMPLE_H
extern int add(int x,int y);
#endif
/* c语言实现文件：cExample.c */
#include "cExample.h"
int add( int x, int y )
{
return x + y;
}
// c++实现文件，调用add：cppFile.cpp
extern "C" 
{
#include "cExample.h"
}
int main(int argc, char* argv[])
{
add(2,3); 
return 0;
}

\end{verbatim} 
　　如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern "C" {　}。
\subsubsection{在C中引用C++语言中的函数和变量}
　在C中引用C++语言中的函数和变量时，C++的头文件需添加extern "C"，但是在C语言中不能直接引用声明了extern "C"的该头文件，应该仅将C文件中将C++中定义的extern "C"函数声明为extern类型。
　　笔者编写的C引用C++函数例子工程中包含的三个文件的源代码如下：
\begin{verbatim}
 //C++头文件 cppExample.h
#ifndef CPP_EXAMPLE_H
#define CPP_EXAMPLE_H
extern "C" int add( int x, int y );
#endif
//C++实现文件 cppExample.cpp
#include "cppExample.h"
int add( int x, int y )
{
return x + y;
}
/* C实现文件 cFile.c
/* 这样会编译出错：#include "cExample.h" */
extern int add( int x, int y );
int main( int argc, char* argv[] )
{
add( 2, 3 ); 
return 0;
}
\end{verbatim} 


如果深入理解了第3节中所阐述的extern "C"在编译和连接阶段发挥的作用，就能真正理解本节所阐述的从C++引用C函数和C引用C++函数的惯用法。对第4节给出的示例代码，需要特别留意各个细节。 
\section{Linux平台C语言获取本机IP}
方法一:通过gethostname和gethostbyname
方法二：getifaddrs函数获取网卡的所有IP地址
方法三: getsockname获取某个连接所使用的本地IP

\section{int转为字符串类型的几种方法}
\begin{verbatim}
1.itoa(), itoa是广泛应用的非标准C语言扩展函数, 不能在所有的编译器中使用。某些的编译器（如Windows上的）通常在<stdlib.h>头文件中包含这个函数。

2.sprintf(), 格式化输出函数，但是还是要事先定义一个大小固定的字符数组作为目的字符串

3.CString str； str.Format(``%d'',int);

4. 使用stringstream类

#include <iostream> 
#include <sstream>   
using namespace std;

int main() 
{ 
	int i = 10;   
	stringstream   strstr;   
	strstr << i;   
	string str(strstr.str());   
	cout << "str = " << str << std::endl;   
}

\end{verbatim}

\section{printf的覆盖定义}

用自定义的myprintf定义库函数printf.

先定义myprintf:
\begin{verbatim}

#include <stdio.h>
#include <stdarg.h>

int myprintf (const char *format, ...)
{
  va_list arg;
  int done;
        
  va_start (arg, format);

  char* fmt = (char *)malloc(strlen(format) + 32);
  strcpy(fmt, "myprt begin:\n");
  strcat(fmt, format);
  done = vfprintf(stdout, fmt, arg);
  va_end (arg);
  free(fmt);
  return done;
}

\end{verbatim}

有多方法实现替换。
\subsection{宏替换法}
\begin{verbatim}
int myprintf (const char *format, ...);

#define printf(a, b...) myprintf(a, ##b)
   ...........
    printf(``hello world\n'');
   ...........
#undef printf

   ...........
    printf(``hello world\n'');
   ...........
\end{verbatim}

\subsection{函数指针法}
\begin{verbatim}
int myprintf (const char *format, ...);

{
    int (* printf) (const char *format, ...) = myprintf;
    printf(``hello world\n'');
}

printf(``hello world\n'');
\end{verbatim}


\subsection{interposition}
直接将上文myprintf的名字改为printf即可.


\section{Makefile}

模式行
\begin{verbatim}
vim:set noet:
\end{verbatim}

\section{c语言字符串数字转换函数}
\begin{verbatim}
atof(将字符串转换成浮点型数)
atoi(将字符串转换成整型数)
atol(将字符串转换成长整型数)
strtod(将字符串转换成浮点数)
strtol(将字符串转换成长整型数)
strtoul(将字符串转换成无符号长整型数)：经测试，如果字符串表示的整数大于unsigned long的范围，会转换成2^32-1
toascii(将整型数转换成合法的ASCII 码字符)
toupper(将小写字母转换成大写字母)
tolower(将大写字母转换成小写字母)


     atof(将字符串转换成浮点型数)
相关函数 atoi,atol,strtod,strtol,strtoul
表头文件 #include <stdlib.h>
定义函数 double atof(const char *nptr);
函数说明 atof()会扫描参数nptr字符串,跳过前面的空格字符,直到遇上数
     字或正负符号才开始做转换,而再遇到非数字或字符串结束时
     ('/0')才结束转换,并将结果返回。参数nptr字符串可包含正负
     号、小数点或E(e)来表示指数部分,如123.456或123e-2。
 返回值 返回转换后的浮点型数。
附加说明 atof()与使用strtod(nptr,(char**)NULL)结果相同。
  范例 /* 将字符串a 与字符串b转换成数字后相加*/
     #include<stdlib.h>
     main()
     {
     char *a=”-100.23”;
     char *b=”200e-2”;
     float c;
     c=atof(a)+atof(b);
     printf(“c=%.2f/n”,c);
     }
  执行 c=-98.23
     atoi(将字符串转换成整型数)
相关函数 atof,atol,atrtod,strtol,strtoul
表头文件 #include<stdlib.h>
定义函数 int atoi(const char *nptr);
函数说明 atoi()会扫描参数nptr字符串,跳过前面的空格字符,直到遇上数
     字或正负符号才开始做转换,而再遇到非数字或字符串结束时
     ('/0')才结束转换,并将结果返回。
 返回值 返回转换后的整型数。
附加说明 atoi()与使用strtol(nptr,(char**)NULL,10);结果相同。
  范例 /* 将字符串a 与字符串b转换成数字后相加*/
     #include<stdlib.h>
     mian()
     {
     char a[]=”-100”;
     char b[]=”456”;
     int c;
     c=atoi(a)+atoi(b);
     printf(c=%d/n”,c);
     }
  执行 c=356
     atol(将字符串转换成长整型数)
相关函数 atof,atoi,strtod,strtol,strtoul
表头文件 #include<stdlib.h>
定义函数 long atol(const char *nptr);
函数说明 atol()会扫描参数nptr字符串,跳过前面的空格字符,直到遇上数
     字或正负符号才开始做转换,而再遇到非数字或字符串结束时
     ('/0')才结束转换,并将结果返回。
 返回值 返回转换后的长整型数。
附加说明 atol()与使用strtol(nptr,(char**)NULL,10);结果相同。
  范例 /*将字符串a与字符串b转换成数字后相加*/
     #include<stdlib.h>
     main()
     {
     char a[]=”1000000000”;
     char b[]=” 234567890”;
     long c;
     c=atol(a)+atol(b);
     printf(“c=%d/n”,c);
     }
  执行 c=1234567890
     gcvt(将浮点型数转换为字符串,取四舍五入)
相关函数 ecvt,fcvt,sprintf
表头文件 #include<stdlib.h>
定义函数 char *gcvt(double number,size_t ndigits,char *buf);
函数说明 gcvt()用来将参数number转换成ASCII码字符串,参数ndigits表示
     显示的位数。gcvt()与ecvt()和fcvt()不同的地方在于,gcvt()所
     转换后的字符串包含小数点或正负符号。若转换成功,转换后的字
     符串会放在参数buf指针所指的空间。
 返回值 返回一字符串指针,此地址即为buf指针。
附加说明
  范例 #include<stdlib.h>
     main()
     {
     double a=123.45;
     double b=-1234.56;
     char *ptr;
     int decpt,sign;
     gcvt(a,5,ptr);
     printf(“a value=%s/n”,ptr);
     ptr=gcvt(b,6,ptr);
     printf(“b value=%s/n”,ptr);
     }
  执行 a value=123.45
     b value=-1234.56
     strtod(将字符串转换成浮点数)
相关函数 atoi,atol,strtod,strtol,strtoul
表头文件 #include<stdlib.h>
定义函数 double strtod(const char *nptr,char **endptr);
函数说明 strtod()会扫描参数nptr字符串,跳过前面的空格字符,直到遇上
     数字或正负符号才开始做转换,到出现非数字或字符串结束时
     ('/0')才结束转换,并将结果返回。若endptr不为NULL,则会将遇
     到不合条件而终止的nptr中的字符指针由endptr传回。参数nptr字
     符串可包含正负号、小数点或E(e)来表示指数部分。如123.456或
     123e-2。
 返回值 返回转换后的浮点型数。
附加说明 参考atof()。
  范例 /*将字符串a,b,c 分别采用10,2,16 进制转换成数字*/
     #include<stdlib.h>
     mian()
     {
     char a[]=”1000000000”;
     char b[]=”1000000000”;
     char c[]=”ffff”;
     printf(“a=%d/n”,strtod(a,NULL,10));
     printf(“b=%d/n”,strtod(b,NULL,2));
     printf(“c=%d/n”,strtod(c,NULL,16));
     }
  执行 a=1000000000
     b=512
     c=65535
     strtol(将字符串转换成长整型数)
相关函数 atof,atoi,atol,strtod,strtoul
表头文件 #include<stdlib.h>
定义函数 long int strtol(const char *nptr,char **endptr,int base);
函数说明 strtol()会将参数nptr字符串根据参数base来转换成长整型数。参
     数base范围从2至36,或0。参数base代表采用的进制方式,如base
     值为10则采用10进制,若base值为16则采用16进制等。当base值为0
     时则是采用10进制做转换,但遇到如'0x'前置字符则会使用16进制
     做转换。一开始strtol()会扫描参数nptr字符串,跳过前面的空格
     字符,直到遇上数字或正负符号才开始做转换,再遇到非数字或字
     符串结束时('/0')结束转换,并将结果返回。若参数endptr不为
     NULL,则会将遇到不合条件而终止的nptr中的字符指针由endptr返
     回。
 返回值 返回转换后的长整型数,否则返回ERANGE并将错误代码存入errno
     中。
附加说明 ERANGE指定的转换字符串超出合法范围。
  范例 /* 将字符串a,b,c 分别采用10,2,16进制转换成数字*/
     #include<stdlib.h>
     main()
     {
     char a[]=”1000000000”;
     char b[]=”1000000000”;
     char c[]=”ffff”;
     printf(“a=%d/n”,strtol(a,NULL,10));
     printf(“b=%d/n”,strtol(b,NULL,2));
     printf(“c=%d/n”,strtol(c,NULL,16));
     }
  执行 a=1000000000
     b=512
     c=65535
     strtoul(将字符串转换成无符号长整型数)
相关函数 atof,atoi,atol,strtod,strtol
表头文件 #include<stdlib.h>
定义函数 unsigned long int strtoul(const char *nptr,char
     **endptr,int base);

函数说明 strtoul()会将参数nptr字符串根据参数base来转换成无符号的长整
     型数。参数base范围从2至36,或0。参数base代表采用的进制方
     式,如base值为10则采用10进制,若base值为16则采用16进制数
     等。当base值为0时则是采用10进制做转换,但遇到如'0x'前置字符
     则会使用16进制做转换。一开始strtoul()会扫描参数nptr字符串,
     跳过前面的空格字符串,直到遇上数字或正负符号才开始做转换,
     再遇到非数字或字符串结束时('/0')结束转换,并将结果返回。若
     参数endptr不为NULL,则会将遇到不合条件而终止的nptr中的字符
     指针由endptr返回。
 返回值 返回转换后的长整型数,否则返回ERANGE并将错误代码存入errno
     中。
附加说明 ERANGE指定的转换字符串超出合法范围。
  范例 参考strtol()
     toascii(将整型数转换成合法的ASCII 码字符)
相关函数 isascii,toupper,tolower
表头文件 #include<ctype.h>
定义函数 int toascii(int c)
函数说明 toascii()会将参数c转换成7位的unsigned char值,第八位则会被
     清除,此字符即会被转成ASCII码字符。
 返回值 将转换成功的ASCII码字符值返回。
  范例 #include<stdlib.h>
     main()
     {
     int a=217;
     char b;
     printf(“before toascii () : a value =%d(%c)/n”,a,a);
     b=toascii(a);
     printf(“after toascii() : a value =%d(%c)/n”,b,b);
     }
  执行 before toascii() : a value =217()
     after toascii() : a value =89(Y)
     tolower(将大写字母转换成小写字母)
相关函数 isalpha,toupper
表头文件 #include<stdlib.h>
定义函数 int tolower(int c);
函数说明 若参数c为大写字母则将该对应的小写字母返回。
 返回值 返回转换后的小写字母,若不须转换则将参数c值返回。
附加说明
  范例 /* 将s字符串内的大写字母转换成小写字母*/
     #include<ctype.h>
     main()
     {
     char s[]=”aBcDeFgH12345;!#$”;
     int i;
     printf(“before tolower() : %s/n”,s);
     for(i=0;I<sizeof(s);i++)
     s[i]=tolower(s[i]);
     printf(“after tolower() : %s/n”,s);
     }
  执行 before tolower() : aBcDeFgH12345;!#$
     after tolower() : abcdefgh12345;!#$
     toupper(将小写字母转换成大写字母)
相关函数 isalpha,tolower
表头文件 #include<ctype.h>
定义函数 int toupper(int c);
函数说明 若参数c为小写字母则将该对映的大写字母返回。
 返回值 返回转换后的大写字母,若不须转换则将参数c值返回。
附加说明
  范例 /* 将s字符串内的小写字母转换成大写字母*/
     #include<ctype.h>
     main()
     {
     char s[]=”aBcDeFgH12345;!#$”;
     int i;
     printf(“before toupper() : %s/n”,s);
     for(i=0;I<sizeof(s);i++)
     s[i]=toupper(s[i]);
     printf(“after toupper() : %s/n”,s);
     }
  执行 before toupper() : aBcDeFgH12345;!#$
     after toupper() : ABCDEFGH12345;!#$



 
\end{verbatim}
\section{C/C++中的日期和时间}
\begin{verbatim}
摘要： 
本文从介绍基础概念入手，探讨了在C/C++中对日期和时间操作所用到的数据结构和函数，并对计时、时间的获取、时间的计算和显示格式等方面进行了阐述。本文还通过大量的实例向你展示了time.h头文件中声明的各种函数和数据结构的详细使用方法。 

关键字： 
UTC（世界标准时间），Calendar Time（日历时间），epoch（时间点），clock tick（时钟计时单元） 

1．概念 
在C/C++中，对字符串的操作有很多值得注意的问题，同样，C/C++对时间的操作也有许多值得大家注意的地方。最近，在技术群中有很多网友也多次问到过C++语言中对时间的操作、获取和显示等等的问题。下面，在这篇文章中，笔者将主要介绍在C/C++中时间和日期的使用方法.

通过学习许多C/C++库，你可以有很多操作、使用时间的方法。但在这之前你需要了解一些“时间”和“日期”的概念，主要有以下几个： 
Coordinated Universal Time（UTC）：协调世界时，又称为世界标准时间，也就是大家所熟知的格林威治标准时间（Greenwich Mean Time，GMT）。比如，中国内地的时间与UTC的时差为+8，也就是UTC+8。美国是UTC-5。 
Calendar Time：日历时间，是用“从一个标准时间点到此时的时间经过的秒数”来表示的时间。这个标准时间点对不同的编译器来说会有所不同，但对一个编译系统来说，这个标准时间点是不变的，该编译系统中的时间对应的日历时间都通过该标准时间点来衡量，所以可以说日历时间是“相对时间”，但是无论你在哪一个时区，在同一时刻对同一个标准时间点来说，日历时间都是一样的。 
epoch：时间点。时间点在标准C/C++中是一个整数，它用此时的时间和标准时间点相差的秒数（即日历时间）来表示。 
clock tick：时钟计时单元（而不把它叫做时钟滴答次数），一个时钟计时单元的时间长短是由CPU控制的。一个clock tick不是CPU的一个时钟周期，而是C/C++的一个基本计时单位。 

我们可以使用ANSI标准库中的time.h头文件。这个头文件中定义的时间和日期所使用的方法，无论是在结构定义，还是命名，都具有明显的C语言风格。下面，我将说明在C/C++中怎样使用日期的时间功能。 

2． 计时 
C/C++中的计时函数是clock()，而与其相关的数据类型是clock_t。在MSDN中，查得对clock函数定义如下： 
clock_t clock( void ); 
这个函数返回从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元（clock tick）数，在MSDN中称之为挂钟时间（wal-clock）。其中clock_t是用来保存时间的数据类型，在time.h文件中，我们可以找到对它的定义： 
#ifndef _CLOCK_T_DEFINED 
typedef long clock_t; 
#define _CLOCK_T_DEFINED 
#endif 
很明显，clock_t是一个长整形数。在time.h文件中，还定义了一个常量CLOCKS_PER_SEC，它用来表示一秒钟会有多少个时钟计时单元，其定义如下： 
#define CLOCKS_PER_SEC ((clock_t)1000) 
可以看到每过千分之一秒（1毫秒），调用clock（）函数返回的值就加1。下面举个例子，你可以使用公式clock()/CLOCKS_PER_SEC来计算一个进程自身的运行时间： 
void elapsed_time() 
{ 
printf("Elapsed time:%u secs.\n",clock()/CLOCKS_PER_SEC); 
} 
当然，你也可以用clock函数来计算你的机器运行一个循环或者处理其它事件到底花了多少时间： 
#include “stdio.h” 
#include “stdlib.h” 
#include “time.h” 
int main( void ) 
{ 
long i = 10000000L; 
clock_t start, finish; 
double duration; 
/* 测量一个事件持续的时间*/ 
printf( "Time to do %ld empty loops is ", i ); 
start = clock(); 
while( i-- ) 
finish = clock(); 
duration = (double)(finish - start) / CLOCKS_PER_SEC; 
printf( "%f seconds\n", duration ); 
system("pause"); 
} 

在笔者的机器上，运行结果如下： 
Time to do 10000000 empty loops is 0.03000 seconds 
上面我们看到时钟计时单元的长度为1毫秒，那么计时的精度也为1毫秒，那么我们可不可以通过改变CLOCKS_PER_SEC的定义，通过把它定义的大一些，从而使计时精度更高呢？通过尝试，你会发现这样是不行的。在标准C/C++中，最小的计时单位是一毫秒。 

3．与日期和时间相关的数据结构 

在标准C/C++中，我们可通过tm结构来获得日期和时间，tm结构在time.h中的定义如下： 
#ifndef _TM_DEFINED 
struct tm { 
int tm_sec; /* 秒 – 取值区间为[0,59] */ 
int tm_min; /* 分 - 取值区间为[0,59] */ 
int tm_hour; /* 时 - 取值区间为[0,23] */ 
int tm_mday; /* 一个月中的日期 - 取值区间为[1,31] */ 
int tm_mon; /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */ 
int tm_year; /* 年份，其值等于实际年份减去1900 */ 
int tm_wday; /* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */
int tm_yday; /* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */ 
int tm_isdst; /* 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负。*/ 
}; 
#define _TM_DEFINED 
#endif 

ANSI C标准称使用tm结构的这种时间表示为分解时间(broken-down time)。而日历时间（Calendar Time）是通过time_t数据类型来表示的，用time_t表示的时间（日历时间）是从一个时间点（例如：1970年1月1日0时0分0秒）到此时的秒数。在time.h中，我们也可以看到time_t是一个长整型数： 
#ifndef _TIME_T_DEFINED 
typedef long time_t; /* 时间值 */ 
#define _TIME_T_DEFINED /* 避免重复定义 time_t */ 
#endif 

大家可能会产生疑问：既然time_t实际上是长整型，到未来的某一天，从一个时间点（一般是1970年1月1日0时0分0秒）到那时的秒数（即日历时间）超出了长整形所能表示的数的范围怎么办？对time_t数据类型的值来说，它所表示的时间不能晚于2038年1月18日19时14分07秒。为了能够表示更久远的时间，一些编译器厂商引入了64位甚至更长的整形数来保存日历时间。比如微软在Visual C++中采用了__time64_t数据类型来保存日历时间，并通过_time64()函数来获得日历时间（而不是通过使用32位字的time()函数），这样就可以通过该数据类型保存3001年1月1日0时0分0秒（不包括该时间点）之前的时间。 

在time.h头文件中，我们还可以看到一些函数，它们都是以time_t为参数类型或返回值类型的函数： 
double difftime(time_t time1, time_t time0); 
time_t mktime(struct tm * timeptr); 
time_t time(time_t * timer); 
char * asctime(const struct tm * timeptr); 
char * ctime(const time_t *timer); 

此外，time.h还提供了两种不同的函数将日历时间（一个用time_t表示的整数）转换为我们平时看到的把年月日时分秒分开显示的时间格式tm： 

struct tm * gmtime(const time_t *timer); 
struct tm * localtime(const time_t * timer); 

通过查阅MSDN，我们可以知道Microsoft C/C++ 7.0中时间点的值（time_t对象的值）是从1899年12月31日0时0分0秒到该时间点所经过的秒数，而其它各种版本的Microsoft C/C++和所有不同版本的Visual C++都是计算的从1970年1月1日0时0分0秒到该时间点所经过的秒数。 

4．与日期和时间相关的函数及应用 

在本节，我将向大家展示怎样利用time.h中声明的函数对时间进行操作。这些操作包括取当前时间、计算时间间隔、以不同的形式显示时间等内容。 

4.1 获得日历时间 

我们可以通过time()函数来获得日历时间（Calendar Time），其原型为：time_t time(time_t * timer); 
如果你已经声明了参数timer，你可以从参数timer返回现在的日历时间，同时也可以通过返回值返回现在的日历时间，即从一个时间点（例如：1970年1月1日0时0分0秒）到现在此时的秒数。如果参数为空（NUL），函数将只通过返回值返回现在的日历时间，比如下面这个例子用来显示当前的日历时间： 

#include "time.h" 
#include "stdio.h" 
int main(void) 
{ 
struct tm *ptr; 
time_t lt; 
lt =time(NUL); 
printf("The Calendar Time now is %d\n",lt); 
return 0; 
} 

运行的结果与当时的时间有关，我当时运行的结果是： 

The Calendar Time now is 1122707619 

其中1122707619就是我运行程序时的日历时间。即从1970年1月1日0时0分0秒到此时的秒数。 

4.2 获得日期和时间 

这里说的日期和时间就是我们平时所说的年、月、日、时、分、秒等信息。从第2节我们已经知道这些信息都保存在一个名为tm的结构体中，那么如何将一个日历时间保存为一个tm结构的对象呢？ 

其中可以使用的函数是gmtime()和localtime()，这两个函数的原型为： 

struct tm * gmtime(const time_t *timer); 
struct tm * localtime(const time_t * timer); 

其中gmtime()函数是将日历时间转化为世界标准时间（即格林尼治时间），并返回一个tm结构体来保存这个时间，而localtime()函数是将日历时间转化为本地时间。比如现在用gmtime()函数获得的世界标准时间是2005年7月30日7点18分20秒，那么我用localtime()函数在中国地区获得的本地时间会比世界标准时间晚8个小时，即2005年7月30日15点18分20秒。下面是个例子： 
#include "time.h" 
#include "stdio.h" 
int main(void) 
{ 
struct tm *local; 
time_t t; 
t=time(NUL); 
local=localtime(&t); 
printf("Local hour is: %d\n",local->tm_hour); 
local=gmtime(&t); 
printf("UTC hour is: %d\n",local->tm_hour); 
return 0; 
} 

运行结果是： 

Local hour is: 15 
UTC hour is: 7 

4.3 固定的时间格式 

我们可以通过asctime()函数和ctime()函数将时间以固定的格式显示出来，两者的返回值都是char*型的字符串。返回的时间格式为： 

星期几 月份 日期 时:分:秒 年\n\0 
例如：Wed Jan 02 02:03:55 1980\n\0 

其中\n是一个换行符，\0是一个空字符，表示字符串结束。下面是两个函数的原型： 
char * asctime(const struct tm * timeptr); 
char * ctime(const time_t *timer); 
其中asctime()函数是通过tm结构来生成具有固定格式的保存时间信息的字符串，而ctime()是通过日历时间来生成时间字符串。这样的话，asctime（）函数只是把tm结构对象中的各个域填到时间字符串的相应位置就行了，而ctime（）函数需要先参照本地的时间设置，把日历时间转化为本地时间，然后再生成格式化后的字符串。在下面，如果t是一个非空的time_t变量的话，那么： 
printf(ctime(&t)); 
等价于： 
struct tm *ptr; 
ptr=localtime(&t); 
printf(asctime(ptr)); 
那么，下面这个程序的两条printf语句输出的结果就是不同的了（除非你将本地时区设为世界标准时间所在的时区）： 

#include "time.h" 
#include "stdio.h" 
int main(void) 
{ 
struct tm *ptr; 
time_t lt; 
lt =time(NUL); 
ptr=gmtime(<); 
printf(asctime(ptr)); 
printf(ctime(<)); 
return 0; 
} 

运行结果： 

Sat Jul 30 08:43:03 2005 
Sat Jul 30 16:43:03 2005 

4.4 自定义时间格式 

我们可以使用strftime（）函数将时间格式化为我们想要的格式。它的原型如下： 

size_t strftime( 
char *strDest, 
size_t maxsize, 
const char *format, 
const struct tm *timeptr 
); 

我们可以根据format指向字符串中格式命令把timeptr中保存的时间信息放在strDest指向的字符串中，最多向strDest中存放maxsize个字符。该函数返回向strDest指向的字符串中放置的字符数。 

函数strftime()的操作有些类似于sprintf()：识别以百分号(%)开始的格式命令集合，格式化输出结果放在一个字符串中。格式化命令说明串strDest中各种日期和时间信息的确切表示方法。格式串中的其他字符原样放进串中。格式命令列在下面，它们是区分大小写的。 

%a 星期几的简写 
%A 星期几的全称 
%b 月分的简写 
%B 月份的全称 
%c 标准的日期的时间串 
%C 年份的后两位数字 
%d 十进制表示的每月的第几天 
%D 月/天/年 
%e 在两字符域中，十进制表示的每月的第几天 
%F 年-月-日 
%g 年份的后两位数字，使用基于周的年 
%G 年分，使用基于周的年 
%h 简写的月份名 
%H 24小时制的小时 
%I 12小时制的小时 
%j 十进制表示的每年的第几天 
%m 十进制表示的月份 
%M 十时制表示的分钟数 
%n 新行符 
%p 本地的AM或PM的等价显示 
%r 12小时的时间 
%R 显示小时和分钟：hh:mm 
%S 十进制的秒数 
%t 水平制表符 
%T 显示时分秒：hh:mm:ss 
%u 每周的第几天，星期一为第一天 （值从0到6，星期一为0） 
%U 第年的第几周，把星期日做为第一天（值从0到53） 
%V 每年的第几周，使用基于周的年 
%w 十进制表示的星期几（值从0到6，星期天为0） 
%W 每年的第几周，把星期一做为第一天（值从0到53） 
%x 标准的日期串 
%X 标准的时间串 
%y 不带世纪的十进制年份（值从0到99） 
%Y 带世纪部分的十进制年份 
%z，%Z 时区名称，如果不能得到时区名称则返回空字符。 
%% 百分号 

如果想显示现在是几点了，并以12小时制显示，就象下面这段程序： 

#include “time.h” 
#include “stdio.h” 
int main(void) 
{ 
struct tm *ptr; 
time_t lt; 
char str[80]; 
lt=time(NUL); 
ptr=localtime(<); 
strftime(str,100,"It is now %I %p",ptr); 
printf(str); 
return 0; 
} 

其运行结果为： 
It is now 4PM 

而下面的程序则显示当前的完整日期： 

#include <stdio.h> 
#include <time.h> 

void main( void ) 
{ 
struct tm *newtime; 
char tmpbuf[128]; 
time_t lt1; 
time( <1 ); 
newtime=localtime(<1); 
strftime( tmpbuf, 128, "Today is %A, day %d of %B in the year %Y.\n", newtime); 
printf(tmpbuf); 
} 

运行结果： 

Today is Saturday, day 30 of July in the year 2005. 

4.5 计算持续时间的长度 

有时候在实际应用中要计算一个事件持续的时间长度，比如计算打字速度。在第1节计时部分中，我已经用clock函数举了一个例子。Clock()函数可以精确到毫秒级。同时，我们也可以使用difftime()函数，但它只能精确到秒。该函数的定义如下： 

double difftime(time_t time1, time_t time0); 

虽然该函数返回的以秒计算的时间间隔是double类型的，但这并不说明该时间具有同double一样的精确度，这是由它的参数觉得的（time_t是以秒为单位计算的）。比如下面一段程序： 

#include "time.h" 
#include "stdio.h" 
#include "stdlib.h" 
int main(void) 
{ 
time_t start,end; 
start = time(NUL); 
system("pause"); 
end = time(NUL); 
printf("The pause used %f seconds.\n",difftime(end,start));//<- 
system("pause"); 
return 0; 
} 

运行结果为： 
请按任意键继续. . . 
The pause used 2.000000 seconds. 
请按任意键继续. . . 

可以想像，暂停的时间并不那么巧是整整2秒钟。其实，你将上面程序的带有“//<-”注释的一行用下面的一行代码替换： 

printf("The pause used %f seconds.\n",end-start); 

其运行结果是一样的。 

4.6 分解时间转化为日历时间 

这里说的分解时间就是以年、月、日、时、分、秒等分量保存的时间结构，在C/C++中是tm结构。我们可以使用mktime（）函数将用tm结构表示的时间转化为日历时间。其函数原型如下：
time_t mktime(struct tm * timeptr); 
其返回值就是转化后的日历时间。这样我们就可以先制定一个分解时间，然后对这个时间进行操作了，下面的例子可以计算出1997年7月1日是星期几： 
#include "time.h" 
#include "stdio.h" 
#include "stdlib.h" 
int main(void) 
{ 
struct tm t; 
time_t t_of_day; 
t.tm_year=1997-1900; 
t.tm_mon=6; 
t.tm_mday=1; 
t.tm_hour=0; 
t.tm_min=0; 
t.tm_sec=1; 
t.tm_isdst=0; 
t_of_day=mktime(&t); 
printf(ctime(&t_of_day)); 
return 0; 
} 
运行结果： 
Tue Jul 01 00:00:01 1997 

现在注意了，有了mktime()函数，是不是我们可以操作现在之前的任何时间呢？你可以通过这种办法算出1945年8月15号是星期几吗？答案是否定的。因为这个时间在1970年1月1日之前，所以在大多数编译器中，这样的程序虽然可以编译通过，但运行时会异常终止。 

5．总结 

本文介绍了标准C/C++中的有关日期和时间的概念，并通过各种实例讲述了这些函数和数据结构的使用方法。笔者认为，和时间相关的一些概念是相当重要的，理解这些概念是理解各种时间格式的转换的基础，更是应用这些函数和数据结构的基础。
\end{verbatim}
\section{程序计时}
在Linux上使用gettimeofday函数获取timeval结构体，内含微秒级字段。clock函数也提供了一种定时机制，但定时单元取决于系统。我遇到的都是1微秒。
在OCTEON上有cvmx\_get\_cycle函数获取时钟周期数，处以主频可以精确计时。
\section{C/C++中的日期和时间}
\begin{verbatim}
摘要： 
本文从介绍基础概念入手，探讨了在C/C++中对日期和时间操作所用到的数据结构和函数，并对计时、时间的获取、时间的计算和显示格式等方面进行了阐述。本文还通过大量的实例向你展示了time.h头文件中声明的各种函数和数据结构的详细使用方法。 

关键字： 
UTC（世界标准时间），Calendar Time（日历时间），epoch（时间点），clock tick（时钟计时单元） 

1．概念 
在C/C++中，对字符串的操作有很多值得注意的问题，同样，C/C++对时间的操作也有许多值得大家注意的地方。最近，在技术群中有很多网友也多次问到过C++语言中对时间的操作、获取和显示等等的问题。下面，在这篇文章中，笔者将主要介绍在C/C++中时间和日期的使用方法.

通过学习许多C/C++库，你可以有很多操作、使用时间的方法。但在这之前你需要了解一些“时间”和“日期”的概念，主要有以下几个： 
Coordinated Universal Time（UTC）：协调世界时，又称为世界标准时间，也就是大家所熟知的格林威治标准时间（Greenwich Mean Time，GMT）。比如，中国内地的时间与UTC的时差为+8，也就是UTC+8。美国是UTC-5。 
Calendar Time：日历时间，是用“从一个标准时间点到此时的时间经过的秒数”来表示的时间。这个标准时间点对不同的编译器来说会有所不同，但对一个编译系统来说，这个标准时间点是不变的，该编译系统中的时间对应的日历时间都通过该标准时间点来衡量，所以可以说日历时间是“相对时间”，但是无论你在哪一个时区，在同一时刻对同一个标准时间点来说，日历时间都是一样的。 
epoch：时间点。时间点在标准C/C++中是一个整数，它用此时的时间和标准时间点相差的秒数（即日历时间）来表示。 
clock tick：时钟计时单元（而不把它叫做时钟滴答次数），一个时钟计时单元的时间长短是由CPU控制的。一个clock tick不是CPU的一个时钟周期，而是C/C++的一个基本计时单位。 

我们可以使用ANSI标准库中的time.h头文件。这个头文件中定义的时间和日期所使用的方法，无论是在结构定义，还是命名，都具有明显的C语言风格。下面，我将说明在C/C++中怎样使用日期的时间功能。 

2． 计时 
C/C++中的计时函数是clock()，而与其相关的数据类型是clock_t。在MSDN中，查得对clock函数定义如下： 
clock_t clock( void ); 
这个函数返回从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元（clock tick）数，在MSDN中称之为挂钟时间（wal-clock）。其中clock_t是用来保存时间的数据类型，在time.h文件中，我们可以找到对它的定义： 
#ifndef _CLOCK_T_DEFINED 
typedef long clock_t; 
#define _CLOCK_T_DEFINED 
#endif 
很明显，clock_t是一个长整形数。在time.h文件中，还定义了一个常量CLOCKS_PER_SEC，它用来表示一秒钟会有多少个时钟计时单元，其定义如下： 
#define CLOCKS_PER_SEC ((clock_t)1000) 
可以看到每过千分之一秒（1毫秒），调用clock（）函数返回的值就加1。下面举个例子，你可以使用公式clock()/CLOCKS_PER_SEC来计算一个进程自身的运行时间： 
void elapsed_time() 
{ 
printf("Elapsed time:%u secs.\n",clock()/CLOCKS_PER_SEC); 
} 
当然，你也可以用clock函数来计算你的机器运行一个循环或者处理其它事件到底花了多少时间： 
#include “stdio.h” 
#include “stdlib.h” 
#include “time.h” 
int main( void ) 
{ 
long i = 10000000L; 
clock_t start, finish; 
double duration; 
/* 测量一个事件持续的时间*/ 
printf( "Time to do %ld empty loops is ", i ); 
start = clock(); 
while( i-- ) 
finish = clock(); 
duration = (double)(finish - start) / CLOCKS_PER_SEC; 
printf( "%f seconds\n", duration ); 
system("pause"); 
} 

在笔者的机器上，运行结果如下： 
Time to do 10000000 empty loops is 0.03000 seconds 
上面我们看到时钟计时单元的长度为1毫秒，那么计时的精度也为1毫秒，那么我们可不可以通过改变CLOCKS_PER_SEC的定义，通过把它定义的大一些，从而使计时精度更高呢？通过尝试，你会发现这样是不行的。在标准C/C++中，最小的计时单位是一毫秒。 

3．与日期和时间相关的数据结构 

在标准C/C++中，我们可通过tm结构来获得日期和时间，tm结构在time.h中的定义如下： 
#ifndef _TM_DEFINED 
struct tm { 
int tm_sec; /* 秒 – 取值区间为[0,59] */ 
int tm_min; /* 分 - 取值区间为[0,59] */ 
int tm_hour; /* 时 - 取值区间为[0,23] */ 
int tm_mday; /* 一个月中的日期 - 取值区间为[1,31] */ 
int tm_mon; /* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */ 
int tm_year; /* 年份，其值等于实际年份减去1900 */ 
int tm_wday; /* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */
int tm_yday; /* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */ 
int tm_isdst; /* 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负。*/ 
}; 
#define _TM_DEFINED 
#endif 

ANSI C标准称使用tm结构的这种时间表示为分解时间(broken-down time)。而日历时间（Calendar Time）是通过time_t数据类型来表示的，用time_t表示的时间（日历时间）是从一个时间点（例如：1970年1月1日0时0分0秒）到此时的秒数。在time.h中，我们也可以看到time_t是一个长整型数： 
#ifndef _TIME_T_DEFINED 
typedef long time_t; /* 时间值 */ 
#define _TIME_T_DEFINED /* 避免重复定义 time_t */ 
#endif 

大家可能会产生疑问：既然time_t实际上是长整型，到未来的某一天，从一个时间点（一般是1970年1月1日0时0分0秒）到那时的秒数（即日历时间）超出了长整形所能表示的数的范围怎么办？对time_t数据类型的值来说，它所表示的时间不能晚于2038年1月18日19时14分07秒。为了能够表示更久远的时间，一些编译器厂商引入了64位甚至更长的整形数来保存日历时间。比如微软在Visual C++中采用了__time64_t数据类型来保存日历时间，并通过_time64()函数来获得日历时间（而不是通过使用32位字的time()函数），这样就可以通过该数据类型保存3001年1月1日0时0分0秒（不包括该时间点）之前的时间。 

在time.h头文件中，我们还可以看到一些函数，它们都是以time_t为参数类型或返回值类型的函数： 
double difftime(time_t time1, time_t time0); 
time_t mktime(struct tm * timeptr); 
time_t time(time_t * timer); 
char * asctime(const struct tm * timeptr); 
char * ctime(const time_t *timer); 

此外，time.h还提供了两种不同的函数将日历时间（一个用time_t表示的整数）转换为我们平时看到的把年月日时分秒分开显示的时间格式tm： 

struct tm * gmtime(const time_t *timer); 
struct tm * localtime(const time_t * timer); 

通过查阅MSDN，我们可以知道Microsoft C/C++ 7.0中时间点的值（time_t对象的值）是从1899年12月31日0时0分0秒到该时间点所经过的秒数，而其它各种版本的Microsoft C/C++和所有不同版本的Visual C++都是计算的从1970年1月1日0时0分0秒到该时间点所经过的秒数。 

4．与日期和时间相关的函数及应用 

在本节，我将向大家展示怎样利用time.h中声明的函数对时间进行操作。这些操作包括取当前时间、计算时间间隔、以不同的形式显示时间等内容。 

4.1 获得日历时间 

我们可以通过time()函数来获得日历时间（Calendar Time），其原型为：time_t time(time_t * timer); 
如果你已经声明了参数timer，你可以从参数timer返回现在的日历时间，同时也可以通过返回值返回现在的日历时间，即从一个时间点（例如：1970年1月1日0时0分0秒）到现在此时的秒数。如果参数为空（NUL），函数将只通过返回值返回现在的日历时间，比如下面这个例子用来显示当前的日历时间： 

#include "time.h" 
#include "stdio.h" 
int main(void) 
{ 
struct tm *ptr; 
time_t lt; 
lt =time(NUL); 
printf("The Calendar Time now is %d\n",lt); 
return 0; 
} 

运行的结果与当时的时间有关，我当时运行的结果是： 

The Calendar Time now is 1122707619 

其中1122707619就是我运行程序时的日历时间。即从1970年1月1日0时0分0秒到此时的秒数。 

4.2 获得日期和时间 

这里说的日期和时间就是我们平时所说的年、月、日、时、分、秒等信息。从第2节我们已经知道这些信息都保存在一个名为tm的结构体中，那么如何将一个日历时间保存为一个tm结构的对象呢？ 

其中可以使用的函数是gmtime()和localtime()，这两个函数的原型为： 

struct tm * gmtime(const time_t *timer); 
struct tm * localtime(const time_t * timer); 

其中gmtime()函数是将日历时间转化为世界标准时间（即格林尼治时间），并返回一个tm结构体来保存这个时间，而localtime()函数是将日历时间转化为本地时间。比如现在用gmtime()函数获得的世界标准时间是2005年7月30日7点18分20秒，那么我用localtime()函数在中国地区获得的本地时间会比世界标准时间晚8个小时，即2005年7月30日15点18分20秒。下面是个例子： 
#include "time.h" 
#include "stdio.h" 
int main(void) 
{ 
struct tm *local; 
time_t t; 
t=time(NUL); 
local=localtime(&t); 
printf("Local hour is: %d\n",local->tm_hour); 
local=gmtime(&t); 
printf("UTC hour is: %d\n",local->tm_hour); 
return 0; 
} 

运行结果是： 

Local hour is: 15 
UTC hour is: 7 

4.3 固定的时间格式 

我们可以通过asctime()函数和ctime()函数将时间以固定的格式显示出来，两者的返回值都是char*型的字符串。返回的时间格式为： 

星期几 月份 日期 时:分:秒 年\n\0 
例如：Wed Jan 02 02:03:55 1980\n\0 

其中\n是一个换行符，\0是一个空字符，表示字符串结束。下面是两个函数的原型： 
char * asctime(const struct tm * timeptr); 
char * ctime(const time_t *timer); 
其中asctime()函数是通过tm结构来生成具有固定格式的保存时间信息的字符串，而ctime()是通过日历时间来生成时间字符串。这样的话，asctime（）函数只是把tm结构对象中的各个域填到时间字符串的相应位置就行了，而ctime（）函数需要先参照本地的时间设置，把日历时间转化为本地时间，然后再生成格式化后的字符串。在下面，如果t是一个非空的time_t变量的话，那么： 
printf(ctime(&t)); 
等价于： 
struct tm *ptr; 
ptr=localtime(&t); 
printf(asctime(ptr)); 
那么，下面这个程序的两条printf语句输出的结果就是不同的了（除非你将本地时区设为世界标准时间所在的时区）： 

#include "time.h" 
#include "stdio.h" 
int main(void) 
{ 
struct tm *ptr; 
time_t lt; 
lt =time(NUL); 
ptr=gmtime(<); 
printf(asctime(ptr)); 
printf(ctime(<)); 
return 0; 
} 

运行结果： 

Sat Jul 30 08:43:03 2005 
Sat Jul 30 16:43:03 2005 

4.4 自定义时间格式 

我们可以使用strftime（）函数将时间格式化为我们想要的格式。它的原型如下： 

size_t strftime( 
char *strDest, 
size_t maxsize, 
const char *format, 
const struct tm *timeptr 
); 

我们可以根据format指向字符串中格式命令把timeptr中保存的时间信息放在strDest指向的字符串中，最多向strDest中存放maxsize个字符。该函数返回向strDest指向的字符串中放置的字符数。 

函数strftime()的操作有些类似于sprintf()：识别以百分号(%)开始的格式命令集合，格式化输出结果放在一个字符串中。格式化命令说明串strDest中各种日期和时间信息的确切表示方法。格式串中的其他字符原样放进串中。格式命令列在下面，它们是区分大小写的。 

%a 星期几的简写 
%A 星期几的全称 
%b 月分的简写 
%B 月份的全称 
%c 标准的日期的时间串 
%C 年份的后两位数字 
%d 十进制表示的每月的第几天 
%D 月/天/年 
%e 在两字符域中，十进制表示的每月的第几天 
%F 年-月-日 
%g 年份的后两位数字，使用基于周的年 
%G 年分，使用基于周的年 
%h 简写的月份名 
%H 24小时制的小时 
%I 12小时制的小时 
%j 十进制表示的每年的第几天 
%m 十进制表示的月份 
%M 十时制表示的分钟数 
%n 新行符 
%p 本地的AM或PM的等价显示 
%r 12小时的时间 
%R 显示小时和分钟：hh:mm 
%S 十进制的秒数 
%t 水平制表符 
%T 显示时分秒：hh:mm:ss 
%u 每周的第几天，星期一为第一天 （值从0到6，星期一为0） 
%U 第年的第几周，把星期日做为第一天（值从0到53） 
%V 每年的第几周，使用基于周的年 
%w 十进制表示的星期几（值从0到6，星期天为0） 
%W 每年的第几周，把星期一做为第一天（值从0到53） 
%x 标准的日期串 
%X 标准的时间串 
%y 不带世纪的十进制年份（值从0到99） 
%Y 带世纪部分的十进制年份 
%z，%Z 时区名称，如果不能得到时区名称则返回空字符。 
%% 百分号 

如果想显示现在是几点了，并以12小时制显示，就象下面这段程序： 

#include “time.h” 
#include “stdio.h” 
int main(void) 
{ 
struct tm *ptr; 
time_t lt; 
char str[80]; 
lt=time(NUL); 
ptr=localtime(<); 
strftime(str,100,"It is now %I %p",ptr); 
printf(str); 
return 0; 
} 

其运行结果为： 
It is now 4PM 

而下面的程序则显示当前的完整日期： 

#include <stdio.h> 
#include <time.h> 

void main( void ) 
{ 
struct tm *newtime; 
char tmpbuf[128]; 
time_t lt1; 
time( <1 ); 
newtime=localtime(<1); 
strftime( tmpbuf, 128, "Today is %A, day %d of %B in the year %Y.\n", newtime); 
printf(tmpbuf); 
} 

运行结果： 

Today is Saturday, day 30 of July in the year 2005. 

4.5 计算持续时间的长度 

有时候在实际应用中要计算一个事件持续的时间长度，比如计算打字速度。在第1节计时部分中，我已经用clock函数举了一个例子。Clock()函数可以精确到毫秒级。同时，我们也可以使用difftime()函数，但它只能精确到秒。该函数的定义如下： 

double difftime(time_t time1, time_t time0); 

虽然该函数返回的以秒计算的时间间隔是double类型的，但这并不说明该时间具有同double一样的精确度，这是由它的参数觉得的（time_t是以秒为单位计算的）。比如下面一段程序： 

#include "time.h" 
#include "stdio.h" 
#include "stdlib.h" 
int main(void) 
{ 
time_t start,end; 
start = time(NUL); 
system("pause"); 
end = time(NUL); 
printf("The pause used %f seconds.\n",difftime(end,start));//<- 
system("pause"); 
return 0; 
} 

运行结果为： 
请按任意键继续. . . 
The pause used 2.000000 seconds. 
请按任意键继续. . . 

可以想像，暂停的时间并不那么巧是整整2秒钟。其实，你将上面程序的带有“//<-”注释的一行用下面的一行代码替换： 

printf("The pause used %f seconds.\n",end-start); 

其运行结果是一样的。 

4.6 分解时间转化为日历时间 

这里说的分解时间就是以年、月、日、时、分、秒等分量保存的时间结构，在C/C++中是tm结构。我们可以使用mktime（）函数将用tm结构表示的时间转化为日历时间。其函数原型如下：
time_t mktime(struct tm * timeptr); 
其返回值就是转化后的日历时间。这样我们就可以先制定一个分解时间，然后对这个时间进行操作了，下面的例子可以计算出1997年7月1日是星期几： 
#include "time.h" 
#include "stdio.h" 
#include "stdlib.h" 
int main(void) 
{ 
struct tm t; 
time_t t_of_day; 
t.tm_year=1997-1900; 
t.tm_mon=6; 
t.tm_mday=1; 
t.tm_hour=0; 
t.tm_min=0; 
t.tm_sec=1; 
t.tm_isdst=0; 
t_of_day=mktime(&t); 
printf(ctime(&t_of_day)); 
return 0; 
} 
运行结果： 
Tue Jul 01 00:00:01 1997 

现在注意了，有了mktime()函数，是不是我们可以操作现在之前的任何时间呢？你可以通过这种办法算出1945年8月15号是星期几吗？答案是否定的。因为这个时间在1970年1月1日之前，所以在大多数编译器中，这样的程序虽然可以编译通过，但运行时会异常终止。 

5．总结 

本文介绍了标准C/C++中的有关日期和时间的概念，并通过各种实例讲述了这些函数和数据结构的使用方法。笔者认为，和时间相关的一些概念是相当重要的，理解这些概念是理解各种时间格式的转换的基础，更是应用这些函数和数据结构的基础。
\end{verbatim}
